#' Function for exchanging knot locations and re-fitting model to find best one
#'
#'
#' @author Cameron Walker, Department of Enginering Science, University of Auckland.
#'
#' @export
#'

################################################################################################################
"exchange.step_2d" <- function(gap,knotDist,radii,dists,explData,response,knotgrid,maxIterations,fitnessMeasure, point,knotPoint,position,aR,BIC,track,out.lm,improveEx, maxKnots,tol=0,baseModel,radiusIndices,models, interactionTerm, data, initDisp, cv.opts, basis, hdetest){

  #attributes(baseModel$formula)$.Environment<-environment()

  # Loop - fuse used to ensure algorithm terminates
  print("******************************************************************************")
  print("Exchanging...")
  print("******************************************************************************")
  # cat('Current Fit in: ', BIC, '\n')
  fuse <- 0
  improve <- 1

  while ( (improve) & (fuse < maxIterations) ) {
    fuse <- fuse + 1
    improve <- 0
    if (isS4(out.lm)){
      abs_resids <- abs(residuals(out.lm, type='pearson'))
      indexdat = order(abs_resids, decreasing = TRUE)[1:5]
      for (id in 1:5){
        while (indexdat[id] > nrow(abs_resids)) {
          indexdat[id] <- indexdat - nrow(abs_resids)
        }
      }
    } else {
      indexdat<-order(abs(residuals(out.lm, type='pearson')), decreasing = TRUE)[1:5]
    }
    #### Find available knots
    if(ncol(knotgrid)>2){
      if (isS4(out.lm)){
        # find which linear predictor for  biggest residual
        # residchunk <- knotgrid[indexdat[1],3]
        residchunk<-data$response[indexdat[1]]
        # get reference level
        reflevel <- levels(knotgrid[,3])[length(levels(knotgrid[,3]))]
        if (residchunk==reflevel){
          knotchunkid <- seq(length(point))
          # which aR are in residchunk
          aRresidchunk <- aR
          legPos1<-position
          legPos2<-position[which(apply(knotDist[point[legPos1],aRresidchunk],1,min)>=gap)]
        } else {
          knotchunkid<-c(which(knotgrid[point,3]==residchunk),which(knotgrid[point,3]==reflevel))
          aRresidchunk<-aR[c(which(knotgrid[aR,3]==residchunk), which(knotgrid[aR,3]==reflevel))]
          legPos1<-position[c(which(knotgrid[,3]==residchunk),which(knotgrid[,3]==reflevel))]
          legPos2<-position[which(apply(knotDist[point[legPos1],aRresidchunk],1,min)>=gap)]
        }
        # find distance to top point
        new<-scale(knotgrid[knotchunkid,1:2],center=c(explData[indexdat[1],1],explData[indexdat[1],2]))
        legPos<-legPos1[legPos2]
        index<-knotchunkid[which.min(abs(new[,1])+abs(new[,2]))]
      } else {
        nm<-names(knotgrid)[3]
        residchunk<-eval(parse(text=paste('data$', nm, '[indexdat[1]]')))
        knotchunkid<-which(knotgrid[point,nm]==residchunk)
        # find distance to top point
        new<-scale(knotgrid[point[knotchunkid],1:2],center=c(explData[indexdat[1],1],explData[indexdat[1],2]))
        # which aR are in residchunk
        aRresidchunk<-aR[which(knotgrid[aR,nm]==residchunk)]
        legPos1<-position[which(knotgrid[,nm]==residchunk)]
        # point[legPos1] gives all rows of a given residchunk that are not existing knots
        # aRresidchunk is which existing knot positions are valid for a given residchunk
        # for each legimate knot position for a chunk, find minimum distance to existing knot, check it is greater than gap
        legPos2<-position[which(apply(knotDist[point[legPos1],aRresidchunk],1,min)>=gap)]
        legPos<-legPos1[legPos2]
        index<-knotchunkid[which.min(abs(new[,1])+abs(new[,2]))]
      }
    }else{
      legPos<-point[which(apply(knotDist[point,aR],1,min)>=gap)]
      new<-scale(knotgrid[point,1:2],center=c(explData[indexdat[1],1],explData[indexdat[1],2]))
      index<-which.min(abs(new[,1])+abs(new[,2]))
    }
    # ggplot() + geom_point(data=knotgrid, aes(X1, X2)) + facet_wrap(~yearmonth) +
    #   geom_point(data=knotgrid[point[knotchunkid],], aes(X1, X2), shape=2, size=2)+
    #   geom_point(data=knotgrid[aR,], aes(X1, X2), shape=3, size=2, col='blue') +
    #   geom_point(data=knotgrid[aRresidchunk,], aes(X1, X2), shape=3, size=4, col='blue') +
    #   geom_point(data=knotgrid[point[legPos1],], aes(X1, X2), shape=3, size=2, col='red')+
    #   geom_point(data=knotgrid[point[legPos1[legPos2]],], aes(X1, X2), shape=4, size=2, col='green') +
    #   geom_point(data=knotgrid[point[legPos],], aes(X1, X2), shape=5, size=3, col='maroon') + coord_equal() + geom_point(data=data[indexdat[1],], aes(x.pos, y.pos), size=3, col='thistle') + geom_point(data=knotgrid[point[index],], aes(X1, X2), shape=7, size=3, col='black')
    # 
    
    if (length(legPos)>0) {
      #index<-which.min(abs(new[,1])+abs(new[,2]))
      if (!(any(knotDist[point[index[1]],aR]<gap))) {
        output <- move.knot_2D(radii,dists,explData,index,fitnessMeasure,BIC,aR,point,
                               response,knotgrid,out.lm,improve,improveEx, track,
                               maxKnots,tol,baseModel,radiusIndices,models, interactionTerm, data, initDisp, cv.opts, basis, hdetest)

        improve <- output$improve
        improveEx <- output$improveEx
        models <- thinModels(output$models)
        if (1 - improve) break
        out.lm<-output$out.lm
        track <- output$track
        tempKnot <- output$tempKnot
        if (tempKnot <= length(knotPoint)) {
          position[knotPoint[tempKnot]] <- output$index
          position[point[output$index]] <- 0
          buff <- knotPoint[tempKnot]
          knotPoint[tempKnot] <- point[output$index]
          point[output$index] <- buff
        } else {
          knotPoint<-c(knotPoint,point[output$index])
          position[point[output$index]]<-0
          point<-point[-output$index]
          if (length(point) >= output$index) {
            for (i in output$index:length(point)){
              position[point[i]]<-position[point[i]]-1
            }
          }
        }
        aR <- output$newR
        BIC <- output$fitStat
        radiusIndices <- output$radiusIndices

        ####track<- rbind(track,cbind("exchange",t(aR),BIC[length(BIC)],adjRsq[length(adjRsq)],GCV[length(GCV)]))
      }
    }else {
      print("no legal knot positions available")
    }
  }
  # cat('Current Fit out: ', BIC, '\n')
  list(point=point,knotPoint=knotPoint,position=position,aR=aR,BIC=BIC,track=track,out.lm=out.lm,
       improveEx=improveEx,radiusIndices=radiusIndices,models=models)
}

###############################
